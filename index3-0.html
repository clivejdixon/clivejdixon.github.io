<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Call Handler</title>
        <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
        <style>
            .action-button {
                background-color: black;
                color: yellow;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                margin-top: 0px;
            }
            
            .center {
                text-align: center;
            }
        </style>
    </head>
    <body>
        <div class="center">
            <button class="action-button" onclick="startSequence()">TSN Reset (Conference)</button>
            <div id="ConfirmationMessage" style="margin-top: 20px; font-weight: bold; color: green;"></div>
            <div id="DebugOutput" style="margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 5px; font-family: monospace; font-size: 12px; text-align: left; white-space: pre-wrap; max-height: 400px; overflow-y: auto; display: none;"></div>
            <table class="redTable">
                <tbody id="tabla-container"></tbody>
            </table>
        </div>
    
        <script>
            const CLIENT_ID = 'c7d2a0f9-cfa1-4001-aeba-a5550f690ab1'; // Client ID to change in each Org
            const ENVIRONMENT = 'euw2.pure.cloud';
            const REDIRECT_URI = 'https://clivejdixon.github.io/index3-0.html';
            const QUEUE_ID = '8e75c14e-3d97-44df-9e81-10421015f9cb'; // Queue ID for Wholesale_Global_EN_ResetTSN_Q to change in each Org
            const SPEAK_TO_INITIAL = 'BOTH';
            const SPEAK_TO_FINAL = 'CONFERENCE';
            const SHOWDEBUG = true; // Set to false to hide debug information
            const WAITTIME = 1000;

            // WebSocket variables
            let websocket = null;
            let notificationChannelId = null;
            let isMonitoringParticipants = false;

            function getTokenAndStateFromHash() {
                const hash = window.location.hash.substring(1);
                const params = new URLSearchParams(hash);
                const token = params.get('access_token');
                const state = params.get('state');
                console.log("Received state:", state);
                let conversationId = null;
                let agentParticipantId = null;
                let customerParticipantId = null;
                let consultingUserId = null;

                if (state) {
                    try {
                        const decodedState = decodeURIComponent(state);
                        const parsed = JSON.parse(atob(decodedState));
                        conversationId = parsed.conversationId;
                        agentParticipantId = parsed.agentParticipantId;
                        customerParticipantId = parsed.customerParticipantId;
                        consultingUserId = parsed.consultingUserId;
                        console.log("Parsed from state:", parsed);
                    } catch (e) {
                        console.error("Error decoding state:", e);
                    }
                }

                return { token, conversationId, agentParticipantId, customerParticipantId, consultingUserId };
            }

            function getParametersFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                return {
                    conversationId: urlParams.get('conversationId'),
                    agentParticipantId: urlParams.get('agentParticipantId'),
                    customerParticipantId: urlParams.get('customerParticipantId'),
                    consultingUserId: urlParams.get('consultingUserId')
                };
            }

            // First try to get parameters from OAuth callback (hash)
            let { token: gToken, conversationId, agentParticipantId, customerParticipantId, consultingUserId } = getTokenAndStateFromHash();

            // If no token, we need to start OAuth flow
            if (!gToken) {
                // Get parameters from URL
                const urlParams = getParametersFromUrl();
                
                if (!urlParams.conversationId || !urlParams.agentParticipantId || !urlParams.customerParticipantId || !urlParams.consultingUserId) {
                    alert("Missing parameters in the URL. Cannot continue.");
                    throw new Error("Missing parameters in the URL");
                }

                // Store parameters in state for OAuth flow
                const state = btoa(JSON.stringify({
                    conversationId: urlParams.conversationId,
                    agentParticipantId: urlParams.agentParticipantId,
                    customerParticipantId: urlParams.customerParticipantId,
                    consultingUserId: urlParams.consultingUserId                
                }));
                console.log("Redirecting with state:", state);

                const authUrl = `https://login.${ENVIRONMENT}/oauth/authorize?` + 
                    $.param({
                        response_type: 'token',
                        client_id: CLIENT_ID,
                        redirect_uri: REDIRECT_URI,
                        state: state
                    });
                window.location.replace(authUrl);
            } else {
                // We have a token, parameters should be in the state
                if (!conversationId || !agentParticipantId || !customerParticipantId || !consultingUserId) {
                    alert("Missing parameters in OAuth callback. Cannot continue.");
                    throw new Error("Missing parameters in OAuth callback");
                }

                console.log("Token obtained:", gToken);
                console.log("conversationId:", conversationId);
                console.log("agentParticipantId:", agentParticipantId);
                console.log("customerParticipantId:", customerParticipantId);
                console.log("consultingUserId:", consultingUserId);            

                const BASE_API_URL = `https://api.${ENVIRONMENT}/api/v2/conversations/calls/${conversationId}`;

                // Initialize debug display
                const debugOutput = document.getElementById("DebugOutput");
                if (SHOWDEBUG) {
                    debugOutput.style.display = 'block';
                }

                function addDebugLine(message) {
                    if (SHOWDEBUG) {
                        const timestamp = new Date().toLocaleTimeString();
                        debugOutput.textContent += `[${timestamp}] ${message}\n`;
                        debugOutput.scrollTop = debugOutput.scrollHeight;
                    }
                }

                function sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                async function makeApiCall(endpoint, method, data, description = '') {
                    try {
                        if (SHOWDEBUG) {
                            addDebugLine(`${description}\nCalling: ${method} ${endpoint}\nPayload: ${JSON.stringify(data, null, 2)}`);
                        }
                        
                        const response = await $.ajax({
                            url: endpoint,
                            type: method,
                            beforeSend: function(xhr) {
                                xhr.setRequestHeader('Authorization', 'Bearer ' + gToken);
                            },
                            data: JSON.stringify(data),
                            contentType: 'application/json'
                        });
                        
                        console.log(`${method} response:`, response);
                        if (SHOWDEBUG) {
                            addDebugLine(`‚úÖ SUCCESS: Status 200\nResponse: ${JSON.stringify(response, null, 2)}\n`);
                        }
                        return response;
                    } catch (error) {
                        console.error(`${method} error:`, error);
                        const errorText = error.responseText || error.statusText || error.message || 'Unknown error';
                        const statusCode = error.status || 'Unknown';
                        if (SHOWDEBUG) {
                            addDebugLine(`‚ùå ERROR: Status ${statusCode}\nError: ${errorText}\n`);
                        }
                        throw error;
                    }
                }

                // WebSocket notification functions
                async function setupWebSocketNotifications() {
                    try {
                        // Step 1: Create notification channel
                        if (SHOWDEBUG) addDebugLine('üîå Setting up WebSocket notifications...');
                        
                        const channelResponse = await makeApiCall(
                            `https://api.${ENVIRONMENT}/api/v2/notifications/channels`,
                            'POST',
                            {},
                            'Creating notification channel'
                        );
                        
                        notificationChannelId = channelResponse.id;
                        const websocketUri = channelResponse.connectUri;
                        
                        // Step 2: Subscribe to conversation events
                        await makeApiCall(
                            `https://api.${ENVIRONMENT}/api/v2/notifications/channels/${notificationChannelId}/subscriptions`,
                            'POST',
                            [{
                                topicName: `v2.detail.events.conversation.${conversationId}.customer.end`
                            }],
                            'Subscribing to customer disconnect notifications'
                        );
                        
                        // Step 3: Connect WebSocket
                        websocket = new WebSocket(websocketUri);
                        
                        websocket.onopen = function() {
                            if (SHOWDEBUG) addDebugLine('‚úÖ WebSocket connected successfully');
                        };
                        
                        websocket.onmessage = function(event) {
                            const notification = JSON.parse(event.data);
                            handleParticipantNotification(notification);
                        };
                        
                        websocket.onerror = function(error) {
                            console.error('WebSocket error:', error);
                            if (SHOWDEBUG) addDebugLine('‚ùå WebSocket error: ' + JSON.stringify(error));
                        };
                        
                        websocket.onclose = function() {
                            if (SHOWDEBUG) addDebugLine('üîå WebSocket connection closed');
                        };
                        
                        return true; // Success
                        
                    } catch (error) {
                        console.error('Failed to setup WebSocket notifications:', error);
                        if (SHOWDEBUG) addDebugLine('‚ö†Ô∏è WebSocket setup failed - continuing without notifications: ' + error.message);
                        return false; // Failed but don't throw
                    }
                }

                function handleParticipantNotification(notification) {
                    if (!isMonitoringParticipants) return;
                    
                    // Check if this is a customer disconnect event
                    if (notification.topicName && 
                        notification.topicName.includes('customer.end') && 
                        notification.eventBody) {
                        
                        const eventBody = notification.eventBody;
                        
                        if (SHOWDEBUG) {
                            addDebugLine(`üìû Customer disconnect event received:`);
                            addDebugLine(`   Disconnect Type: ${eventBody.disconnectType}`);
                            addDebugLine(`   Participant ID: ${eventBody.participantId?.substring(0,8)}...`);
                            addDebugLine(`   Duration: ${eventBody.interactingDurationMs}ms`);
                        }
                        
                        // Check if this is an ENDPOINT disconnect (customer hanging up)
                        if (eventBody.disconnectType === 'ENDPOINT') {
                            if (SHOWDEBUG) addDebugLine('üéØ Customer ENDPOINT disconnect detected - taking agent off hold...');
                            
                            // Stop monitoring to prevent multiple triggers
                            isMonitoringParticipants = false;
                            
                            // Take agent off hold
                            takeAgentOffHold();
                        } else {
                            if (SHOWDEBUG) addDebugLine(`‚ÑπÔ∏è Ignoring disconnect type: ${eventBody.disconnectType}`);
                        }
                    }
                }

                async function takeAgentOffHold() {
                    try {
                        await makeApiCall(
                            `${BASE_API_URL}/participants/${agentParticipantId}`,
                            'PATCH',
                            {
                                held: false
                            },
                            'FINAL STEP: Taking agent off hold'
                        );
                        
                        if (SHOWDEBUG) addDebugLine('üéâ Agent taken off hold - TSN Reset sequence complete!');
                        document.getElementById("ConfirmationMessage").textContent = "‚úÖ TSN Reset completed - Agent off hold";
                        
                        // Clean up WebSocket after successful completion
                        cleanupWebSocket();
                        
                    } catch (error) {
                        console.error("Error taking agent off hold:", error);
                        if (SHOWDEBUG) addDebugLine(`‚ùå Error taking agent off hold: ${error.responseText || error.message}`);
                        document.getElementById("ConfirmationMessage").textContent = "‚ùå Error taking agent off hold";
                    }
                }

                function cleanupWebSocket() {
                    if (websocket) {
                        websocket.close();
                        websocket = null;
                        if (SHOWDEBUG) addDebugLine('üßπ WebSocket cleaned up');
                    }
                    isMonitoringParticipants = false;
                }

                // Clean up on page unload
                window.addEventListener('beforeunload', function() {
                    cleanupWebSocket();
                });

                window.startSequence = async function() {
                    document.getElementById("ConfirmationMessage").textContent = "Processing...";
                    if (SHOWDEBUG) {
                        debugOutput.textContent = ''; // Clear previous debug output
                    }

                    try {
                        // Try to setup WebSocket notifications (non-blocking)
                        const websocketSetupSuccess = await setupWebSocketNotifications();
                        
                        // Step 1: Try POST consult first, fallback to POST participants
                        let step1Success = false;
                        try {
                            // Step 1a: POST consult
                            await makeApiCall(
                                `${BASE_API_URL}/participants/${customerParticipantId}/consult`,
                                'POST',
                                {
                                    speakTo: SPEAK_TO_INITIAL,
                                    destination: {
                                        queueId: QUEUE_ID
                                    },
                                    consultingUserId: consultingUserId
                                },
                                'STEP 1a: Creating consultation'
                            );
                            step1Success = true;
                        } catch (error) {
                            if (SHOWDEBUG) addDebugLine(`‚ö†Ô∏è Step 1a failed (likely already in conference), trying fallback approach...`);
                            
                            try {
                                // Step 1b: POST participants (fallback)
                                await makeApiCall(
                                    `${BASE_API_URL}/participants`,
                                    'POST',
                                    {
                                        "participants": [{"queueId": QUEUE_ID}]
                                    },
                                    'STEP 1b: Adding queue to conference (fallback)'
                                );
                                step1Success = true;
                                if (SHOWDEBUG) addDebugLine('‚úÖ Step 1b fallback succeeded - skipping to Step 3 (conference already active)');
                                
                                // Skip Steps 2 and go directly to Step 3 since we're already in conference mode
                                if (SHOWDEBUG) addDebugLine('‚è≥ Waiting 1 second before final step...');
                                await sleep(WAITTIME);
                                
                                // Step 3: PATCH participant held
                                await makeApiCall(
                                    `${BASE_API_URL}/participants/${agentParticipantId}`,
                                    'PATCH',
                                    {
                                        held: true
                                    },
                                    'STEP 3: Placing agent on hold'
                                );

                                // Start monitoring for participant changes (only if WebSocket is working)
                                if (websocketSetupSuccess) {
                                    isMonitoringParticipants = true;
                                    if (SHOWDEBUG) addDebugLine('üëÅÔ∏è Now monitoring for customer disconnections...');
                                    document.getElementById("ConfirmationMessage").textContent = "‚úÖ Agent on hold - Monitoring for disconnections";
                                } else {
                                    if (SHOWDEBUG) addDebugLine('‚ö†Ô∏è WebSocket monitoring unavailable - sequence completed');
                                    document.getElementById("ConfirmationMessage").textContent = "‚úÖ Agent on hold - Manual monitoring required";
                                }
                                
                                return; // Exit early since we've completed the sequence
                            } catch (fallbackError) {
                                if (SHOWDEBUG) addDebugLine(`‚ùå Both Step 1a and 1b failed`);
                                throw fallbackError; // Re-throw to trigger main error handling
                            }
                        }

                        // Wait time pause
                        if (SHOWDEBUG) addDebugLine('‚è≥ Waiting 1 second...');
                        await sleep(WAITTIME);

                        // Step 2: Try PATCH consult first, fallback to POST participants
                        let step2Success = false;
                        try {
                            // Step 2a: PATCH consult
                            await makeApiCall(
                                `${BASE_API_URL}/participants/${customerParticipantId}/consult`,
                                'PATCH',
                                {
                                    speakTo: SPEAK_TO_FINAL,
                                    consultingUserId: consultingUserId
                                },
                                'STEP 2a: Updating consultation speak mode'
                            );
                            step2Success = true;
                        } catch (error) {
                            if (SHOWDEBUG) addDebugLine(`‚ö†Ô∏è Step 2a failed, trying fallback approach...`);
                            
                            try {
                                // Step 2b: POST participants (fallback)
                                await makeApiCall(
                                    `${BASE_API_URL}/participants`,
                                    'POST',
                                    {
                                        "participants": [{"queueId": QUEUE_ID}]
                                    },
                                    'STEP 2b: Adding queue to conference (fallback)'
                                );
                                step2Success = true;
                                if (SHOWDEBUG) addDebugLine('‚úÖ Step 2b fallback succeeded');
                            } catch (fallbackError) {
                                if (SHOWDEBUG) addDebugLine(`‚ùå Both Step 2a and 2b failed`);
                                throw fallbackError; // Re-throw to trigger main error handling
                            }
                        }

                        // Wait time pause
                        if (SHOWDEBUG) addDebugLine('‚è≥ Waiting 1 second...');
                        await sleep(WAITTIME);

                        // Step 3: PATCH participant held
                        await makeApiCall(
                            `${BASE_API_URL}/participants/${agentParticipantId}`,
                            'PATCH',
                            {
                                held: true
                            },
                            'STEP 3: Placing agent on hold'
                        );

                        // Start monitoring for participant changes (only if WebSocket is working)
                        if (websocketSetupSuccess) {
                            isMonitoringParticipants = true;
                            if (SHOWDEBUG) addDebugLine('üëÅÔ∏è Now monitoring for customer disconnections...');
                            if (SHOWDEBUG) addDebugLine('üéâ Initial sequence completed successfully!');
                            document.getElementById("ConfirmationMessage").textContent = "‚úÖ Agent on hold - Monitoring for disconnections";
                        } else {
                            if (SHOWDEBUG) addDebugLine('‚ö†Ô∏è WebSocket monitoring unavailable - sequence completed');
                            if (SHOWDEBUG) addDebugLine('üéâ Initial sequence completed successfully!');
                            document.getElementById("ConfirmationMessage").textContent = "‚úÖ Agent on hold - Manual monitoring required";
                        }
                        
                    } catch (error) {
                        console.error("Sequence error:", error);
                        if (SHOWDEBUG) addDebugLine(`üí• SEQUENCE FAILED: ${error.responseText || error.message}`);
                        document.getElementById("ConfirmationMessage").textContent = "‚ùå Error during sequence execution: " + (error.responseText || error.message);
                        
                        // Clean up on error
                        cleanupWebSocket();
                    }
                };
            }
        </script>
    </body>
</html>
