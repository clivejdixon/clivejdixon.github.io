<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Call Handler - Minimal</title>
        <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
        <style>
            .action-button {
                background-color: black;
                color: yellow;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                margin-top: 0px;
            }
            
            .center {
                text-align: center;
            }
        </style>
    </head>
    <body>
        <div class="center">
            <button class="action-button" onclick="startSequence()">TSN Reset (Conference)</button>
        </div>
    
        <script>
            const CLIENT_ID = 'c7d2a0f9-cfa1-4001-aeba-a5550f690ab1';
            const ENVIRONMENT = 'euw2.pure.cloud';
            const REDIRECT_URI = 'https://clivejdixon.github.io/index3-0.html';
            const QUEUE_ID = '8e75c14e-3d97-44df-9e81-10421015f9cb';
            const SPEAK_TO_INITIAL = 'BOTH';
            const SPEAK_TO_FINAL = 'CONFERENCE';
            const WAITTIME = 1000;
            const WEBSOCKET_SETUP_DELAY = 20000; // Configurable WebSocket setup delay
            const MAX_WEBSOCKET_RECONNECT_ATTEMPTS = 5;
            const WEBSOCKET_RECONNECT_DELAY = 2000; // 2 seconds between reconnect attempts
            const WEBSOCKET_HEARTBEAT_INTERVAL = 5000; // 5 seconds

            // Global variables
            let websocket = null;
            let websocketChannelId = null;
            let isMonitoringParticipants = false;
            let websocketReconnectAttempts = 0;
            let websocketHeartbeatInterval = null;
            
            // Global parameters that will be set after authentication
            let gToken = null;
            let conversationId = null;
            let agentParticipantId = null;
            let customerParticipantId = null;
            let consultingUserId = null;
            let BASE_API_URL = null;

            // MAIN SEQUENCE FUNCTION - Now defined globally and always available
            window.startSequence = async function() {
                // Prevent default button behavior and stop event propagation
                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                }                
                console.log('[DEBUG] üñ±Ô∏è TSN Reset button clicked!');
                
                // Check if we have the required parameters
                if (!gToken || !conversationId || !agentParticipantId || !customerParticipantId || !consultingUserId) {
                    const errorMsg = 'Missing required parameters. Please ensure OAuth flow completed successfully.';
                    console.error(errorMsg);
                    alert(errorMsg);
                    return;
                }
                
                // Prevent multiple sequence executions
                if (sequenceRunning) {
                    console.log('[DEBUG] ‚ö†Ô∏è Sequence already running, ignoring request');
                    return;
                }
                
                sequenceRunning = true;
                console.log('[DEBUG] üöÄ 59 Starting TSN Reset sequence...');

                try {
                    // Step 1: Try POST consult first, fallback to POST participants
                    let step1Success = false;
                    try {
                        // Step 1a: POST consult
                        await makeApiCall(
                            `${BASE_API_URL}/participants/${customerParticipantId}/consult`,
                            'POST',
                            {
                                speakTo: SPEAK_TO_INITIAL,
                                destination: {
                                    queueId: QUEUE_ID
                                },
                                consultingUserId: consultingUserId
                            },
                            'STEP 1a: Creating consultation'
                        );
                        step1Success = true;
                    } catch (error) {
                        console.log('[DEBUG] ‚ö†Ô∏è Step 1a failed (likely already in conference), trying fallback approach...');
                        
                        try {
                            // Step 1b: POST participants (fallback)
                            await makeApiCall(
                                `${BASE_API_URL}/participants`,
                                'POST',
                                {
                                    "participants": [{"queueId": QUEUE_ID}]
                                },
                                'STEP 1b: Adding queue to conference (fallback)'
                            );
                            step1Success = true;
                            console.log('[DEBUG] ‚úÖ Step 1b fallback succeeded - skipping to Step 3 (conference already active)');
                            
                            // Skip Steps 2 and go directly to Step 3 since we're already in conference mode
                            console.log('[DEBUG] ‚è≥ Waiting 1 second before final step...');
                            await sleep(WAITTIME);
                            
                            // Step 3: PATCH participant held
                            await makeApiCall(
                                `${BASE_API_URL}/participants/${agentParticipantId}`,
                                'PATCH',
                                {
                                    held: true
                                },
                                'STEP 3: Placing agent on hold'
                            );

                             const monitoringStarted = await setupPersistentWebSocketNotifications();

                             if (monitoringStarted) {
                                isMonitoringParticipants = true;
                                console.log('[DEBUG] ‚úÖ Agent on hold - Persistent WebSocket monitoring active');
                            } else {
                                console.log('[DEBUG] ‚ö†Ô∏è Could not start persistent WebSocket monitoring');
                            }

                        } catch (error) {
                            console.error('‚ùå Sequence error:', error);
                            isMonitoringParticipants = false;
                        }
                    }

                    // Wait time pause
                    console.log('[DEBUG] ‚è≥ Waiting 1 second...');
                    await sleep(WAITTIME);

                    // Step 2: Try PATCH consult first, fallback to POST participants
                    try {
                        // Step 2a: PATCH consult
                        await makeApiCall(
                            `${BASE_API_URL}/participants/${customerParticipantId}/consult`,
                            'PATCH',
                            {
                                speakTo: SPEAK_TO_FINAL,
                                consultingUserId: consultingUserId
                            },
                            'STEP 2a: Updating consultation speak mode'
                        );
                    } catch (error) {
                        console.log('[DEBUG] ‚ö†Ô∏è Step 2a failed, trying fallback approach...');
                        
                        try {
                            // Step 2b: POST participants (fallback)
                            await makeApiCall(
                                `${BASE_API_URL}/participants`,
                                'POST',
                                {
                                    "participants": [{"queueId": QUEUE_ID}]
                                },
                                'STEP 2b: Adding queue to conference (fallback)'
                            );
                            console.log('[DEBUG] ‚úÖ Step 2b fallback succeeded');
                        } catch (fallbackError) {
                            console.log('[DEBUG] ‚ùå Both Step 2a and 2b failed');
                            throw fallbackError;
                        }
                    }

                    // Wait time pause
                    console.log('[DEBUG] ‚è≥ Waiting 1 second...');
                    await sleep(WAITTIME);

                    // Step 3: PATCH participant held
                    await makeApiCall(
                        `${BASE_API_URL}/participants/${agentParticipantId}`,
                        'PATCH',
                        {
                            held: true
                        },
                        'STEP 3: Placing agent on hold'
                    );
                    const monitoringStarted = await setupPersistentWebSocketNotifications();

                    if (monitoringStarted) {
                        isMonitoringParticipants = true;
                        console.log('[DEBUG] ‚úÖ Agent on hold - Persistent WebSocket monitoring active');
                    } else {
                        console.log('[DEBUG] ‚ö†Ô∏è Could not start persistent WebSocket monitoring');
                    }

                } catch (error) {
                    console.error('‚ùå Sequence error:', error);
                    isMonitoringParticipants = false;
                } finally {
                    // Always reset the sequence running flag
                    sequenceRunning = false;
                }
            };

            function getTokenAndStateFromHash() {
                const hash = window.location.hash.substring(1);
                const params = new URLSearchParams(hash);
                const token = params.get('access_token');
                const state = params.get('state');
                console.log("[DEBUG] Received state:", state);
                let conversationId = null;
                let agentParticipantId = null;
                let customerParticipantId = null;
                let consultingUserId = null;

                if (state) {
                    try {
                        const decodedState = decodeURIComponent(state);
                        const parsed = JSON.parse(atob(decodedState));
                        conversationId = parsed.conversationId;
                        agentParticipantId = parsed.agentParticipantId;
                        customerParticipantId = parsed.customerParticipantId;
                        consultingUserId = parsed.consultingUserId;
                        console.log("[DEBUG] Parsed from state:", parsed);
                    } catch (e) {
                        console.error("Error decoding state:", e);
                    }
                }

                return { token, conversationId, agentParticipantId, customerParticipantId, consultingUserId };
            }

            function getParametersFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                return {
                    conversationId: urlParams.get('conversationId'),
                    agentParticipantId: urlParams.get('agentParticipantId'),
                    customerParticipantId: urlParams.get('customerParticipantId'),
                    consultingUserId: urlParams.get('consultingUserId')
                };
            }

            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async function makeApiCall(endpoint, method, data, description = '') {
                try {
                    console.log(`[DEBUG] ${description} - ${method} ${endpoint}`);
                    
                    const response = await $.ajax({
                        url: endpoint,
                        type: method,
                        beforeSend: function(xhr) {
                            xhr.setRequestHeader('Authorization', 'Bearer ' + gToken);
                        },
                        data: JSON.stringify(data),
                        contentType: 'application/json'
                    });
                    
                    console.log(`[DEBUG] ‚úÖ ${description} - SUCCESS`);
                    return response;
                } catch (error) {
                    console.error(`‚ùå ${description} - ERROR:`, error);
                    throw error;
                }
            }

            // Enhanced WebSocket Setup with Persistence
            async function setupPersistentWebSocketNotifications() {
                try {
                    console.log('üîå Setting up Persistent WebSocket notifications...');
        
                    // Create notification channel
                    const channelResponse = await makeApiCall(
                        `https://api.${ENVIRONMENT}/api/v2/notifications/channels`,
                        'POST',
                        {},
                        'Creating notification channel'
                    );
        
                    websocketChannelId = channelResponse.id;
                    const websocketUri = channelResponse.connectUri;
                    console.log(`[DEBUG] üì° Channel created: ${websocketChannelId}`);
        
                    // Subscribe to conversation events
                    await makeApiCall(
                        `https://api.${ENVIRONMENT}/api/v2/notifications/channels/${websocketChannelId}/subscriptions`,
                        'POST',
                        [{
                            id: `v2.detail.events.conversation.${conversationId}.customer.end`
                        }],
                        'Subscribing to customer disconnect notifications'
                    );
        
                    // Create WebSocket with enhanced connection management
                    websocket = new WebSocket(websocketUri);
        
                    // Store WebSocket connection details in sessionStorage for page reload persistence
                    sessionStorage.setItem('websocketChannelId', websocketChannelId);
                    sessionStorage.setItem('conversationId', conversationId);
        
                    // WebSocket Event Handlers
                    websocket.onopen = function() {
                        console.log('[DEBUG] ‚úÖ WebSocket connected successfully');
                        websocketReconnectAttempts = 0;
            
                        // Setup periodic heartbeat
                        setupWebSocketHeartbeat();
                    };
        
                    websocket.onmessage = function(event) {
                        try {
                            const notification = JSON.parse(event.data);
                            console.log('[DEBUG] üì® WebSocket notification received:', notification);
                            handleParticipantNotification(notification);
                        } catch (error) {
                            console.log(`[DEBUG] ‚ùå Error parsing WebSocket message: ${error.message}`);
                        }
                    };
        
                    websocket.onerror = function(error) {
                        console.error('‚ùå WebSocket error:', error);
                        attemptWebSocketReconnection();
                    };
        
                    websocket.onclose = function(event) {
                        console.log(`[DEBUG] üîå WebSocket connection closed - Code: ${event.code}, Reason: ${event.reason}`);
            
                        // Stop heartbeat on close
                        clearWebSocketHeartbeat();
            
                        // Attempt reconnection if not intentionally closed
                        if (isMonitoringParticipants) {
                            attemptWebSocketReconnection();
                        }
                    };
        
                    return true;
                } catch (error) {
                    console.error('[DEBUG] ‚ùå Persistent WebSocket setup failed:', error);
                    return false;
                }
            }

            // WebSocket Heartbeat Management
            function setupWebSocketHeartbeat() {
                clearWebSocketHeartbeat(); // Clear any existing heartbeat
    
                websocketHeartbeatInterval = setInterval(() => {
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        try {
                            websocket.send(JSON.stringify({
                                type: 'heartbeat', 
                                timestamp: new Date().toISOString()
                            }));
                            console.log('[DEBUG] üíì Sent WebSocket heartbeat');
                        } catch (error) {
                            console.log(`[DEBUG] ‚ùå Heartbeat failed: ${error.message}`);
                              clearWebSocketHeartbeat();
                        }
                    } else {
                        clearWebSocketHeartbeat();
                    }
                }, WEBSOCKET_HEARTBEAT_INTERVAL);
            }

            function clearWebSocketHeartbeat() {
                if (websocketHeartbeatInterval) {
                    clearInterval(websocketHeartbeatInterval);
                    websocketHeartbeatInterval = null;
                }
            }

            // WebSocket Reconnection Strategy
            function attemptWebSocketReconnection() {
                // Increment reconnect attempts
                websocketReconnectAttempts++;
    
                // Check if we've exceeded max reconnect attempts
                if (websocketReconnectAttempts > MAX_WEBSOCKET_RECONNECT_ATTEMPTS) {
                    console.log('[DEBUG] ‚ùå Max WebSocket reconnect attempts reached');
                    isMonitoringParticipants = false;
                    return;
                }
    
                console.log(`üîÑ Attempting WebSocket reconnect (Attempt ${websocketReconnectAttempts})`);
    
                // Use setTimeout to delay reconnection attempt
                setTimeout(async () => {
                    try {
                        // Restore previous connection details from sessionStorage
                        const storedChannelId = sessionStorage.getItem('websocketChannelId');
                        const storedConversationId = sessionStorage.getItem('conversationId');
            
                        if (storedChannelId && storedConversationId) {
                            websocketChannelId = storedChannelId;
                            conversationId = storedConversationId;
                
                            const reconnectSuccess = await setupPersistentWebSocketNotifications();
                
                            if (reconnectSuccess) {
                                console.log('[DEBUG] ‚úÖ WebSocket successfully reconnected');
                                websocketReconnectAttempts = 0; // Reset reconnect attempts
                            } else {
                                throw new Error('WebSocket reconnection failed');
                            }
                        }
                    } catch (reconnectError) {
                        console.log(`[DEBUG] ‚ùå WebSocket reconnection failed: ${reconnectError.message}`);
                        isMonitoringParticipants = false;
                    }
                }, WEBSOCKET_RECONNECT_DELAY);
            }

            // Page Visibility Change Handling
            document.addEventListener('visibilitychange', function() {
                    if (document.visibilityState === 'visible') {
                    // Page becomes visible again - attempt to restore WebSocket if needed
                    if (isMonitoringParticipants && (!websocket || websocket.readyState !== WebSocket.OPEN)) {
                        console.log('[DEBUG] üì° Page visible - attempting WebSocket restoration');
                        attemptWebSocketReconnection();
                    }
                }
            });
            
            // WebSocket notification functions
            async function setupWebSocketNotifications() {
                try {
                    console.log('[DEBUG] üîå Setting up WebSocket notifications...');
                    
                    // Step 1: Create notification channel
                    const channelResponse = await makeApiCall(
                        `https://api.${ENVIRONMENT}/api/v2/notifications/channels`,
                        'POST',
                        {},
                        'Creating notification channel'
                    );
                    
                    notificationChannelId = channelResponse.id;
                    const websocketUri = channelResponse.connectUri;
                    console.log(`[DEBUG] üì° Channel created: ${notificationChannelId}`);
                    
                    // Step 2: Subscribe to conversation events
                    await makeApiCall(
                        `https://api.${ENVIRONMENT}/api/v2/notifications/channels/${notificationChannelId}/subscriptions`,
                        'POST',
                        [{
                            id: `v2.detail.events.conversation.${conversationId}.customer.end`
                        }],
                        'Subscribing to customer disconnect notifications'
                    );
                    
                    console.log(`[DEBUG] üì¨ Subscription created for customer disconnect events`);
                    
                    // Step 3: Connect WebSocket
                    websocket = new WebSocket(websocketUri);
                    
                    websocket.onopen = function() {
                        console.log('[DEBUG] ‚úÖ WebSocket connected successfully');
                    };
                    
                    websocket.onmessage = function(event) {
                        try {
                            const notification = JSON.parse(event.data);
                            console.log('[DEBUG] üì® WebSocket notification received:', notification);
                            handleParticipantNotification(notification);
                        } catch (error) {
                            console.log(`[DEBUG] ‚ùå Error parsing WebSocket message: ${error.message}`);
                        }
                    };
                    
                    websocket.onerror = function(error) {
                        console.error('‚ùå WebSocket error:', error);
                    };
                    
                    websocket.onclose = function(event) {
                        console.log(`[DEBUG] üîå WebSocket connection closed - Code: ${event.code}, Reason: ${event.reason}`);
                        
                         // Only attempt reconnect if not a page update and monitoring is active
                        if (!isPageUpdateDetected && isMonitoringParticipants) {
                            detectUnexpectedWebSocketClose(event);
                        }
                    };
        
                    // Wait a bit for connection to establish
                    await sleep(2000);
        
                    if (websocket.readyState === WebSocket.OPEN) {
                        console.log('[DEBUG] üéØ WebSocket setup completed successfully');
                        return true;
                    } else {
                        console.log(`[DEBUG] ‚ö†Ô∏è WebSocket not fully connected (state: ${websocket.readyState})`);
                        return false;
                    }
        
                } catch (error) {
                    console.error('‚ùå WebSocket setup failed:', error);
                    return false;
                }
            }

            function handleParticipantNotification(notification) {
                console.log(`[DEBUG] üîç Processing notification - Monitoring: ${isMonitoringParticipants}`);
                
                if (!isMonitoringParticipants) {
                    console.log('[DEBUG] ‚è∏Ô∏è Not monitoring participants - ignoring notification');
                    return;
                }
                
                // Check if this is a customer end event
                if (notification.topicName && 
                    notification.topicName.includes('customer.end') && 
                    notification.eventBody) {
                    
                    const eventBody = notification.eventBody;
                    
                    console.log('[DEBUG] üéØ Customer disconnect event detected:');
                    console.log(`[DEBUG]    Disconnect Type: ${eventBody.disconnectType}`);
                    console.log(`[DEBUG]    Participant ID: ${eventBody.participantId}`);
                    
                    // Check if this is an ENDPOINT disconnect (customer hanging up)
                    if (eventBody.disconnectType === 'ENDPOINT') {
                        console.log('[DEBUG] üéØ Customer ENDPOINT disconnect detected - taking agent off hold...');
                        
                        // Stop monitoring to prevent multiple triggers
                        isMonitoringParticipants = false;
                        
                        // Take agent off hold
                        takeAgentOffHold();
                    } else {
                        console.log(`[DEBUG] ‚ÑπÔ∏è Customer disconnected but not ENDPOINT type: ${eventBody.disconnectType}`);
                    }
                } else {
                    console.log('[DEBUG] ‚ÑπÔ∏è Notification not a customer end event');
                }
            }

            async function takeAgentOffHold() {
                try {
                    await makeApiCall(
                        `${BASE_API_URL}/participants/${agentParticipantId}`,
                        'PATCH',
                        {
                            held: false
                        },
                        'FINAL STEP: Taking agent off hold'
                    );
                    
                    console.log('[DEBUG] üéâ Agent taken off hold - TSN Reset sequence complete!');
                    
                    // Clean up WebSocket after successful completion
                    setTimeout(() => {
                        cleanupWebSocket();
                    }, 2000);
                    
                } catch (error) {
                    console.error("‚ùå Error taking agent off hold:", error);
                }
            }

            // Detect page update or unload
            window.addEventListener('beforeunload', function() {
                isPageUpdateDetected = true;
                console.log('[DEBUG] üö® Page update or unload detected');
                cleanupWebSocket(true);
            });

async function detectUnexpectedWebSocketClose(error) {
    console.log('[DEBUG] üîç Detecting unexpected WebSocket close...');
    
    // Check if page update was detected
    if (isPageUpdateDetected) {
        console.log('[DEBUG] ‚úÖ Page update confirmed - suppressing automatic reconnect');
        return;
    }
    
    // Increment reconnect attempts
    websocketReconnectAttempts++;
    
    // Check if we've exceeded max reconnect attempts
    if (websocketReconnectAttempts > MAX_WEBSOCKET_RECONNECT_ATTEMPTS) {
        console.log('[DEBUG] ‚ùå Max WebSocket reconnect attempts reached');
        isMonitoringParticipants = false;
        return;
    }
    
    console.log(`[DEBUG] üîÑ Attempting WebSocket reconnect (Attempt ${websocketReconnectAttempts})`);
    
    try {
        // Wait before attempting reconnect
        await new Promise(resolve => setTimeout(resolve, WEBSOCKET_RECONNECT_DELAY));
        
        // Attempt to set up WebSocket again
        const reconnectSuccess = await setupWebSocketNotifications();
        
        if (reconnectSuccess) {
            console.log('[DEBUG] ‚úÖ WebSocket successfully reconnected');
            websocketReconnectAttempts = 0; // Reset reconnect attempts
        } else {
            throw new Error('WebSocket reconnection failed');
        }
    } catch (reconnectError) {
        console.log(`[DEBUG] ‚ùå WebSocket reconnection failed: ${reconnectError.message}`);
        
        // If reconnection fails, stop monitoring
        isMonitoringParticipants = false;
    }
}
            
            function cleanupWebSocket(isPageUpdate = false) {
                console.log('[DEBUG] üßπ Cleaning up WebSocket...');
                if (websocket) {
                   // Remove event listeners to prevent multiple handlers
                    websocket.onclose = null;
                    websocket.onerror = null;
                    websocket.onmessage = null;
        
                    // Close the WebSocket connection
                    websocket.close();
                    websocket = null;
                }
                // Reset monitoring flags
                isMonitoringParticipants = false;
                sequenceRunning = false;

                // Reset page update flag after a short delay
                if (isPageUpdate) {
                setTimeout(() => {
                    isPageUpdateDetected = false;
                    }, 1000);
                }
            }

            // Initialize the application
            (function initializeApp() {
                console.log('[DEBUG] üöÄ Application starting...');
                
                // First try to get parameters from OAuth callback (hash)
                let { token, conversationId: convId, agentParticipantId: agentId, customerParticipantId: customerId, consultingUserId: consultId } = getTokenAndStateFromHash();

                // If no token, we need to start OAuth flow
                if (!token) {
                    console.log('[DEBUG] üîë No token found, checking URL parameters...');
                    // Get parameters from URL
                    const urlParams = getParametersFromUrl();
                    
                    if (!urlParams.conversationId || !urlParams.agentParticipantId || !urlParams.customerParticipantId || !urlParams.consultingUserId) {
                        const errorMsg = "Missing parameters in the URL. Cannot continue.";
                        console.log(`[DEBUG] ‚ùå ${errorMsg}`);
                        alert(errorMsg);
                        return;
                    }

                    // Store parameters in state for OAuth flow
                    const state = btoa(JSON.stringify({
                        conversationId: urlParams.conversationId,
                        agentParticipantId: urlParams.agentParticipantId,
                        customerParticipantId: urlParams.customerParticipantId,
                        consultingUserId: urlParams.consultingUserId                
                    }));
                    console.log("[DEBUG] üîÑ Redirecting to OAuth...");

                    const authUrl = `https://login.${ENVIRONMENT}/oauth/authorize?` + 
                        $.param({
                            response_type: 'token',
                            client_id: CLIENT_ID,
                            redirect_uri: REDIRECT_URI,
                            state: state
                        });
                    
                    // Use setTimeout to prevent immediate redirect issues
                    setTimeout(() => {
                        window.location.replace(authUrl);
                    }, 100);
                } else {
                    // We have a token, parameters should be in the state
                    if (!convId || !agentId || !customerId || !consultId) {
                        const errorMsg = "Missing parameters in OAuth callback. Cannot continue.";
                        console.log(`‚ùå ${errorMsg}`);
                        alert(errorMsg);
                        return;
                    }

                    // Set global variables
                    gToken = token;
                    conversationId = convId;
                    agentParticipantId = agentId;
                    customerParticipantId = customerId;
                    consultingUserId = consultId;
                    BASE_API_URL = `https://api.${ENVIRONMENT}/api/v2/conversations/calls/${conversationId}`;

                    console.log("[DEBUG] ‚úÖ Authentication complete");
                    console.log(`[DEBUG] üìã Conversation ID: ${conversationId}`);
                    console.log(`[DEBUG] üë§ Agent ID: ${agentParticipantId.substring(0,8)}...`);
                    console.log(`[DEBUG] üìû Customer ID: ${customerParticipantId.substring(0,8)}...`);
                    console.log('[DEBUG] ‚úÖ Ready for TSN Reset - Button is active!');
                    
                    // Clear hash to prevent re-processing
                    if (window.location.hash) {
                        window.history.replaceState(null, null, window.location.pathname + window.location.search);
                    }
                }
            })();

            // Prevent page navigation during monitoring
            window.addEventListener('beforeunload', function(event) {
                if (isMonitoringParticipants && websocket && websocket.readyState === WebSocket.OPEN) {
                    console.log('[DEBUG] ‚ö†Ô∏è Page unload during monitoring - WebSocket may be lost');
                    event.preventDefault();
                    event.returnValue = 'TSN Reset monitoring is active. Leaving will stop monitoring.';
                    return 'TSN Reset monitoring is active. Leaving will stop monitoring.';
                }
            });
        </script>
    </body>
</html>
