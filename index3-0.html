<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Call Handler - Debug Enhanced</title>
        <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
        <style>
            .action-button {
                background-color: black;
                color: yellow;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                margin-top: 0px;
            }
            
            .center {
                text-align: center;
            }

            #DebugOutput {
                margin-top: 20px; 
                padding: 10px; 
                background-color: #f0f0f0; 
                border: 1px solid #ccc; 
                border-radius: 5px; 
                font-family: monospace; 
                font-size: 12px; 
                text-align: left; 
                white-space: pre-wrap; 
                max-height: 400px; 
                overflow-y: auto;
            }
        </style>
    </head>
    <body>
        <div class="center">
            <button class="action-button" onclick="startSequence()">TSN Reset (Conference)</button>
            
            <div id="ConfirmationMessage" style="margin-top: 20px; font-weight: bold; color: green;"></div>
            
            <div id="DebugOutput" style="display: block;"></div>
            
            <table class="redTable">
                <tbody id="tabla-container"></tbody>
            </table>
        </div>
    
        <script>
            const CLIENT_ID = 'c7d2a0f9-cfa1-4001-aeba-a5550f690ab1';
            const ENVIRONMENT = 'euw2.pure.cloud';
            const REDIRECT_URI = 'https://clivejdixon.github.io/index3-0.html';
            const QUEUE_ID = '8e75c14e-3d97-44df-9e81-10421015f9cb';
            const SPEAK_TO_INITIAL = 'BOTH';
            const SPEAK_TO_FINAL = 'CONFERENCE';
            const SHOWDEBUG = true;
            const WAITTIME = 1000;

            // Global variables
            let websocket = null;
            let notificationChannelId = null;
            let isMonitoringParticipants = false;
            let debugBuffer = [];
            let maxDebugLines = 100;
            let sequenceRunning = false;
            
            // Global parameters that will be set after authentication
            let gToken = null;
            let conversationId = null;
            let agentParticipantId = null;
            let customerParticipantId = null;
            let consultingUserId = null;
            let BASE_API_URL = null;

            // Enhanced debug functions
            function addDebugLine(message) {
                if (SHOWDEBUG) {
                    const timestamp = new Date().toLocaleTimeString();
                    const line = `[${timestamp}] ${message}`;
                    
                    // Add to buffer
                    debugBuffer.push(line);
                    if (debugBuffer.length > maxDebugLines) {
                        debugBuffer.shift();
                    }
                    
                    // Update display
                    const debugOutput = document.getElementById("DebugOutput");
                    if (debugOutput) {
                        debugOutput.textContent = debugBuffer.join('\n') + '\n';
                        debugOutput.scrollTop = debugOutput.scrollHeight;
                    }
                    
                    // Also log to console for backup
                    console.log(`[DEBUG] ${message}`);
                }
            }

            function updateWebSocketStatus(status, className) {
                // Removed WebSocket status display as requested
                addDebugLine(`üîÑ WebSocket status: ${status}`);
            }

            // MAIN SEQUENCE FUNCTION - Now defined globally and always available
            window.startSequence = async function() {
                console.log('üñ±Ô∏è TSN Reset button clicked!');
                addDebugLine('üñ±Ô∏è TSN Reset button clicked!');
                
                // Check if we have the required parameters
                if (!gToken || !conversationId || !agentParticipantId || !customerParticipantId || !consultingUserId) {
                    const errorMsg = 'Missing required parameters. Please ensure OAuth flow completed successfully.';
                    console.error(errorMsg);
                    addDebugLine(`‚ùå ${errorMsg}`);
                    alert(errorMsg);
                    return;
                }
                
                // Prevent multiple sequence executions
                if (sequenceRunning) {
                    addDebugLine('‚ö†Ô∏è Sequence already running, ignoring request');
                    return;
                }
                
                sequenceRunning = true;
                document.getElementById("ConfirmationMessage").textContent = "Processing...";
                addDebugLine('üöÄ 45 Starting TSN Reset sequence...');

                try {
                    // Step 1: Try POST consult first, fallback to POST participants
                    let step1Success = false;
                    try {
                        // Step 1a: POST consult
                        await makeApiCall(
                            `${BASE_API_URL}/participants/${customerParticipantId}/consult`,
                            'POST',
                            {
                                speakTo: SPEAK_TO_INITIAL,
                                destination: {
                                    queueId: QUEUE_ID
                                },
                                consultingUserId: consultingUserId
                            },
                            'STEP 1a: Creating consultation'
                        );
                        step1Success = true;
                    } catch (error) {
                        addDebugLine(`‚ö†Ô∏è Step 1a failed (likely already in conference), trying fallback approach...`);
                        
                        try {
                            // Step 1b: POST participants (fallback)
                            await makeApiCall(
                                `${BASE_API_URL}/participants`,
                                'POST',
                                {
                                    "participants": [{"queueId": QUEUE_ID}]
                                },
                                'STEP 1b: Adding queue to conference (fallback)'
                            );
                            step1Success = true;
                            addDebugLine('‚úÖ Step 1b fallback succeeded - skipping to Step 3 (conference already active)');
                            
                            // Skip Steps 2 and go directly to Step 3 since we're already in conference mode
                            addDebugLine('‚è≥ Waiting 1 second before final step...');
                            await sleep(WAITTIME);
                            
                            // Step 3: PATCH participant held
                            await makeApiCall(
                                `${BASE_API_URL}/participants/${agentParticipantId}`,
                                'PATCH',
                                {
                                    held: true
                                },
                                'STEP 3: Placing agent on hold'
                            );

                            // NOW setup WebSocket notifications AFTER agent is on hold
                            addDebugLine('üîå Setting up WebSocket notifications after agent on hold...');
                            const websocketSetupSuccess = await setupWebSocketNotifications();

                            // Start monitoring for participant changes (only if WebSocket is working)
                            if (websocketSetupSuccess) {
                                isMonitoringParticipants = true;
                                updateWebSocketStatus('Monitoring Active', 'status-monitoring');
                                addDebugLine('üëÅÔ∏è Now monitoring for customer disconnections...');
                                document.getElementById("ConfirmationMessage").textContent = "‚úÖ Agent on hold - Monitoring for disconnections";
                            } else {
                                addDebugLine('‚ö†Ô∏è WebSocket monitoring unavailable - sequence completed');
                                document.getElementById("ConfirmationMessage").textContent = "‚úÖ Agent on hold - Manual monitoring required";
                            }
                            
                            return; // Exit early since we've completed the sequence
                        } catch (fallbackError) {
                            addDebugLine(`‚ùå Both Step 1a and 1b failed`);
                            throw fallbackError; // Re-throw to trigger main error handling
                        }
                    }

                    // Wait time pause
                    addDebugLine('‚è≥ Waiting 1 second...');
                    await sleep(WAITTIME);

                    // Step 2: Try PATCH consult first, fallback to POST participants
                    let step2Success = false;
                    try {
                        // Step 2a: PATCH consult
                        await makeApiCall(
                            `${BASE_API_URL}/participants/${customerParticipantId}/consult`,
                            'PATCH',
                            {
                                speakTo: SPEAK_TO_FINAL,
                                consultingUserId: consultingUserId
                            },
                            'STEP 2a: Updating consultation speak mode'
                        );
                        step2Success = true;
                    } catch (error) {
                        addDebugLine(`‚ö†Ô∏è Step 2a failed, trying fallback approach...`);
                        
                        try {
                            // Step 2b: POST participants (fallback)
                            await makeApiCall(
                                `${BASE_API_URL}/participants`,
                                'POST',
                                {
                                    "participants": [{"queueId": QUEUE_ID}]
                                },
                                'STEP 2b: Adding queue to conference (fallback)'
                            );
                            step2Success = true;
                            addDebugLine('‚úÖ Step 2b fallback succeeded');
                        } catch (fallbackError) {
                            addDebugLine(`‚ùå Both Step 2a and 2b failed`);
                            throw fallbackError; // Re-throw to trigger main error handling
                        }
                    }

                    // Wait time pause
                    addDebugLine('‚è≥ Waiting 1 second...');
                    await sleep(WAITTIME);

                    // Step 3: PATCH participant held
                    await makeApiCall(
                        `${BASE_API_URL}/participants/${agentParticipantId}`,
                        'PATCH',
                        {
                            held: true
                        },
                        'STEP 3: Placing agent on hold'
                    );

                    // NOW setup WebSocket notifications AFTER agent is on hold
                    addDebugLine('üîå Setting up WebSocket notifications after agent on hold...');
                    const websocketSetupSuccess = await setupWebSocketNotifications();

                    // Start monitoring for participant changes (only if WebSocket is working)
                    if (websocketSetupSuccess) {
                        isMonitoringParticipants = true;
                        updateWebSocketStatus('Monitoring Active', 'status-monitoring');
                        addDebugLine('üëÅÔ∏è Now monitoring for customer disconnections...');
                        addDebugLine('üéâ Initial sequence completed successfully!');
                        document.getElementById("ConfirmationMessage").textContent = "‚úÖ Agent on hold - Monitoring for disconnections";
                    } else {
                        addDebugLine('‚ö†Ô∏è WebSocket monitoring unavailable - sequence completed');
                        addDebugLine('üéâ Initial sequence completed successfully!');
                        document.getElementById("ConfirmationMessage").textContent = "‚úÖ Agent on hold - Manual monitoring required";
                    }
                    
                } catch (error) {
                    console.error("Sequence error:", error);
                    addDebugLine(`üí• SEQUENCE FAILED: ${error.responseText || error.message}`);
                    document.getElementById("ConfirmationMessage").textContent = "‚ùå Error during sequence execution: " + (error.responseText || error.message);
                    
                    // Clean up on error
                    cleanupWebSocket();
                } finally {
                    // Always reset the sequence running flag
                    sequenceRunning = false;
                }
            };

            function getTokenAndStateFromHash() {
                const hash = window.location.hash.substring(1);
                const params = new URLSearchParams(hash);
                const token = params.get('access_token');
                const state = params.get('state');
                console.log("Received state:", state);
                let conversationId = null;
                let agentParticipantId = null;
                let customerParticipantId = null;
                let consultingUserId = null;

                if (state) {
                    try {
                        const decodedState = decodeURIComponent(state);
                        const parsed = JSON.parse(atob(decodedState));
                        conversationId = parsed.conversationId;
                        agentParticipantId = parsed.agentParticipantId;
                        customerParticipantId = parsed.customerParticipantId;
                        consultingUserId = parsed.consultingUserId;
                        console.log("Parsed from state:", parsed);
                    } catch (e) {
                        console.error("Error decoding state:", e);
                    }
                }

                return { token, conversationId, agentParticipantId, customerParticipantId, consultingUserId };
            }

            function getParametersFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                return {
                    conversationId: urlParams.get('conversationId'),
                    agentParticipantId: urlParams.get('agentParticipantId'),
                    customerParticipantId: urlParams.get('customerParticipantId'),
                    consultingUserId: urlParams.get('consultingUserId')
                };
            }

            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async function makeApiCall(endpoint, method, data, description = '') {
                try {
                    if (SHOWDEBUG) {
                        addDebugLine(`${description}\nCalling: ${method} ${endpoint}\nPayload: ${JSON.stringify(data, null, 2)}`);
                    }
                    
                    const response = await $.ajax({
                        url: endpoint,
                        type: method,
                        beforeSend: function(xhr) {
                            xhr.setRequestHeader('Authorization', 'Bearer ' + gToken);
                        },
                        data: JSON.stringify(data),
                        contentType: 'application/json'
                    });
                    
                    console.log(`${method} response:`, response);
                    if (SHOWDEBUG) {
                        addDebugLine(`‚úÖ SUCCESS: Status 200\nResponse: ${JSON.stringify(response, null, 2)}\n`);
                    }
                    return response;
                } catch (error) {
                    console.error(`${method} error:`, error);
                    const errorText = error.responseText || error.statusText || error.message || 'Unknown error';
                    const statusCode = error.status || 'Unknown';
                    if (SHOWDEBUG) {
                        addDebugLine(`‚ùå ERROR: Status ${statusCode}\nError: ${errorText}\n`);
                    }
                    throw error;
                }
            }

            // Enhanced WebSocket notification functions
            async function setupWebSocketNotifications() {
                try {
                    addDebugLine('üîå Setting up WebSocket notifications...');
                    
                    // Step 1: Create notification channel
                    const channelResponse = await makeApiCall(
                        `https://api.${ENVIRONMENT}/api/v2/notifications/channels`,
                        'POST',
                        {},
                        'Creating notification channel'
                    );
                    
                    notificationChannelId = channelResponse.id;
                    const websocketUri = channelResponse.connectUri;
                    addDebugLine(`üì° Channel created: ${notificationChannelId}`);
                    addDebugLine(`üîó WebSocket URI: ${websocketUri}`);
                    
                    // Step 2: Subscribe to conversation events - ORIGINAL SUBSCRIPTION
                    const subscriptionResponse = await makeApiCall(
                        `https://api.${ENVIRONMENT}/api/v2/notifications/channels/${notificationChannelId}/subscriptions`,
                        'POST',
                        [{
                            id: `v2.detail.events.conversation.${conversationId}.customer.end`
                        }],
                        'Subscribing to customer disconnect notifications'
                    );
                    
                    addDebugLine(`üì¨ Subscription created for: v2.detail.events.conversation.${conversationId}.customer.end`);
                    
                    // Step 3: Connect WebSocket
                    websocket = new WebSocket(websocketUri);
                    
                    websocket.onopen = function() {
                        addDebugLine('‚úÖ WebSocket connected successfully');
                        updateWebSocketStatus('Connected', 'status-connected');
                    };
                    
                    websocket.onmessage = function(event) {
                        try {
                            const notification = JSON.parse(event.data);
                            addDebugLine(`üì® RAW WebSocket message: ${event.data}`);
                            addDebugLine(`üì® Parsed notification: ${JSON.stringify(notification, null, 2)}`);
                            handleParticipantNotification(notification);
                        } catch (error) {
                            addDebugLine(`‚ùå Error parsing WebSocket message: ${error.message}`);
                            addDebugLine(`üì® Raw data: ${event.data}`);
                        }
                    };
                    
                    websocket.onerror = function(error) {
                        console.error('WebSocket error:', error);
                        addDebugLine(`‚ùå WebSocket error: ${JSON.stringify(error)}`);
                        updateWebSocketStatus('Error', 'status-disconnected');
                    };
                    
                    websocket.onclose = function(event) {
                        addDebugLine(`üîå WebSocket connection closed - Code: ${event.code}, Reason: ${event.reason}`);
                        updateWebSocketStatus('Disconnected', 'status-disconnected');
                    };
                    
                    // Wait a bit for connection to establish
                    await sleep(2000);
                    
                    if (websocket.readyState === WebSocket.OPEN) {
                        addDebugLine('üéØ WebSocket setup completed successfully');
                        addDebugLine(`üîç WebSocket ready state: ${websocket.readyState} (1=OPEN)`);
                        
                        // Send a test message to verify connection
                        try {
                            websocket.send(JSON.stringify({type: 'ping', timestamp: new Date().toISOString()}));
                            addDebugLine('üì§ Sent test ping message to WebSocket');
                        } catch (error) {
                            addDebugLine(`‚ùå Failed to send test ping: ${error.message}`);
                        }
                        
                        return true;
                    } else {
                        addDebugLine(`‚ö†Ô∏è WebSocket not fully connected (state: ${websocket.readyState})`);
                        return false;
                    }
                    
                } catch (error) {
                    console.error('Failed to setup WebSocket notifications:', error);
                    addDebugLine(`‚ùå WebSocket setup failed: ${error.message || error.responseText || 'Unknown error'}`);
                    updateWebSocketStatus('Setup Failed', 'status-disconnected');
                    return false;
                }
            }

            function handleParticipantNotification(notification) {
                addDebugLine(`üîç Processing notification - Monitoring: ${isMonitoringParticipants}`);
                
                // Log ALL notifications regardless of monitoring state
                addDebugLine(`üìã Notification details:`);
                addDebugLine(`   Topic: ${notification.topicName || 'No topic'}`);
                addDebugLine(`   Event Body: ${JSON.stringify(notification.eventBody || {}, null, 2)}`);
                
                if (!isMonitoringParticipants) {
                    addDebugLine('‚è∏Ô∏è Not monitoring participants - but still logging notification');
                    return;
                }
                
                // Check if this is a customer end event
                if (notification.topicName && 
                    notification.topicName.includes('customer.end') && 
                    notification.eventBody) {
                    
                    const eventBody = notification.eventBody;
                    
                    addDebugLine(`üéØ Customer disconnect event detected:`);
                    addDebugLine(`   Disconnect Type: ${eventBody.disconnectType}`);
                    addDebugLine(`   Participant ID: ${eventBody.participantId}`);
                    addDebugLine(`   Purpose: ${eventBody.purpose}`);
                    addDebugLine(`   Duration: ${eventBody.interactingDurationMs}ms`);
                    
                    // Check if this is an ENDPOINT disconnect (customer hanging up)
                    if (eventBody.disconnectType === 'ENDPOINT') {
                        addDebugLine('üéØ Customer ENDPOINT disconnect detected - taking agent off hold...');
                        
                        // Stop monitoring to prevent multiple triggers
                        isMonitoringParticipants = false;
                        updateWebSocketStatus('Processing Disconnect', 'status-monitoring');
                        
                        // Take agent off hold
                        takeAgentOffHold();
                    } else {
                        addDebugLine(`‚ÑπÔ∏è Customer disconnected but not ENDPOINT type: ${eventBody.disconnectType}`);
                    }
                } else {
                    addDebugLine('‚ÑπÔ∏è Notification not a customer end event');
                }
            }

            async function takeAgentOffHold() {
                try {
                    await makeApiCall(
                        `${BASE_API_URL}/participants/${agentParticipantId}`,
                        'PATCH',
                        {
                            held: false
                        },
                        'FINAL STEP: Taking agent off hold'
                    );
                    
                    addDebugLine('üéâ Agent taken off hold - TSN Reset sequence complete!');
                    document.getElementById("ConfirmationMessage").textContent = "‚úÖ TSN Reset completed - Agent off hold";
                    
                    // Clean up WebSocket after successful completion
                    setTimeout(() => {
                        cleanupWebSocket();
                    }, 2000); // Wait 2 seconds before cleanup to see any final messages
                    
                } catch (error) {
                    console.error("Error taking agent off hold:", error);
                    addDebugLine(`‚ùå Error taking agent off hold: ${error.responseText || error.message}`);
                    document.getElementById("ConfirmationMessage").textContent = "‚ùå Error taking agent off hold";
                }
            }

            function cleanupWebSocket() {
                addDebugLine(`üßπ cleanupWebSocket() called - Current state: ${websocket ? websocket.readyState : 'null'}`);
                if (websocket) {
                    websocket.close();
                    websocket = null;
                    addDebugLine('üßπ WebSocket cleaned up');
                }
                isMonitoringParticipants = false;
                sequenceRunning = false;
            }

            // Initialize the application
            (function initializeApp() {
                addDebugLine('üöÄ Application starting...');
                
                // First try to get parameters from OAuth callback (hash)
                let { token, conversationId: convId, agentParticipantId: agentId, customerParticipantId: customerId, consultingUserId: consultId } = getTokenAndStateFromHash();

                // If no token, we need to start OAuth flow
                if (!token) {
                    addDebugLine('üîë No token found, checking URL parameters...');
                    // Get parameters from URL
                    const urlParams = getParametersFromUrl();
                    
                    if (!urlParams.conversationId || !urlParams.agentParticipantId || !urlParams.customerParticipantId || !urlParams.consultingUserId) {
                        const errorMsg = "Missing parameters in the URL. Cannot continue.";
                        addDebugLine(`‚ùå ${errorMsg}`);
                        alert(errorMsg);
                        throw new Error("Missing parameters in the URL");
                    }

                    // Store parameters in state for OAuth flow
                    const state = btoa(JSON.stringify({
                        conversationId: urlParams.conversationId,
                        agentParticipantId: urlParams.agentParticipantId,
                        customerParticipantId: urlParams.customerParticipantId,
                        consultingUserId: urlParams.consultingUserId                
                    }));
                    addDebugLine("üîÑ Redirecting to OAuth with state...");

                    const authUrl = `https://login.${ENVIRONMENT}/oauth/authorize?` + 
                        $.param({
                            response_type: 'token',
                            client_id: CLIENT_ID,
                            redirect_uri: REDIRECT_URI,
                            state: state
                        });
                    window.location.replace(authUrl);
                } else {
                    // We have a token, parameters should be in the state
                    if (!convId || !agentId || !customerId || !consultId) {
                        const errorMsg = "Missing parameters in OAuth callback. Cannot continue.";
                        addDebugLine(`‚ùå ${errorMsg}`);
                        alert(errorMsg);
                        throw new Error("Missing parameters in OAuth callback");
                    }

                    // Set global variables
                    gToken = token;
                    conversationId = convId;
                    agentParticipantId = agentId;
                    customerParticipantId = customerId;
                    consultingUserId = consultId;
                    BASE_API_URL = `https://api.${ENVIRONMENT}/api/v2/conversations/calls/${conversationId}`;

                    console.log("Token obtained:", gToken);
                    console.log("conversationId:", conversationId);
                    console.log("agentParticipantId:", agentParticipantId);
                    console.log("customerParticipantId:", customerParticipantId);
                    console.log("consultingUserId:", consultingUserId);            

                    // Initialize debug display - ONLY ONCE
                    if (!window.debugInitialized) {
                        window.debugInitialized = true;
                        addDebugLine('üöÄ Application initialized');
                        addDebugLine(`üìã Conversation ID: ${conversationId}`);
                        addDebugLine(`üë§ Agent ID: ${agentParticipantId.substring(0,8)}...`);
                        addDebugLine(`üìû Customer ID: ${customerParticipantId.substring(0,8)}...`);
                        addDebugLine(`üîç Page URL: ${window.location.href}`);
                        addDebugLine(`üîç Referrer: ${document.referrer}`);
                        addDebugLine('‚úÖ Ready for TSN Reset - Button is active!');
                    } else {
                        addDebugLine('‚ö†Ô∏è Application already initialized - this is a page reload!');
                        addDebugLine(`üîç Page URL: ${window.location.href}`);
                        addDebugLine(`üîç Referrer: ${document.referrer}`);
                    }
                }
            })();

            // Monitor for page unload but don't cleanup WebSocket automatically
            window.addEventListener('beforeunload', function(event) {
                addDebugLine(`‚ö†Ô∏è Page unload detected - Reason: ${event.type} - WebSocket state: ${websocket ? websocket.readyState : 'null'}`);
                // Don't cleanup WebSocket automatically - let it stay connected
            });

            // Add more event listeners to debug what's causing reloads
            window.addEventListener('pagehide', function(event) {
                addDebugLine(`‚ö†Ô∏è Page hide detected - persisted: ${event.persisted}`);
            });

            window.addEventListener('pageshow', function(event) {
                addDebugLine(`‚ö†Ô∏è Page show detected - persisted: ${event.persisted}`);
            });

            // Prevent form submissions that might reload the page
            document.addEventListener('submit', function(event) {
                addDebugLine(`‚ö†Ô∏è Form submission detected - preventing default`);
                event.preventDefault();
                return false;
            });

            // Check if we're in an iframe that might be reloading
            if (window.parent !== window) {
                addDebugLine(`‚ÑπÔ∏è Running inside iframe - parent: ${window.parent.location.href}`);
            }

            // Add error handling for unhandled promise rejections
            window.addEventListener('unhandledrejection', function(event) {
                addDebugLine(`‚ùå Unhandled promise rejection: ${event.reason}`);
                // Don't prevent default - just log
            });
        </script>
    </body>
</html>
