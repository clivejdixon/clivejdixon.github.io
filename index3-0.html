<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Call Handler - Debug Enhanced</title>
        <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
        <style>
            .action-button {
                background-color: black;
                color: yellow;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                margin-top: 0px;
            }
            
            .center {
                text-align: center;
            }

            .debug-controls {
                margin: 10px 0;
            }

            .debug-controls button {
                margin: 0 5px;
                padding: 5px 10px;
                background-color: #666;
                color: white;
                border: none;
                border-radius: 3px;
                cursor: pointer;
            }

            #DebugOutput {
                margin-top: 20px; 
                padding: 10px; 
                background-color: #f0f0f0; 
                border: 1px solid #ccc; 
                border-radius: 5px; 
                font-family: monospace; 
                font-size: 12px; 
                text-align: left; 
                white-space: pre-wrap; 
                max-height: 400px; 
                overflow-y: auto;
            }

            .websocket-status {
                margin: 10px 0;
                padding: 5px 10px;
                border-radius: 3px;
                font-weight: bold;
            }

            .status-connected { background-color: #d4edda; color: #155724; }
            .status-disconnected { background-color: #f8d7da; color: #721c24; }
            .status-monitoring { background-color: #d1ecf1; color: #0c5460; }
        </style>
    </head>
    <body>
        <div class="center">
            <button class="action-button" onclick="startSequence()">TSN Reset (Conference)</button>
            
            <div class="debug-controls">
                <button onclick="clearDebugOutput()">Clear Debug</button>
                <button onclick="toggleDebugOutput()">Show/Hide Debug</button>
                <button onclick="testWebSocketConnection()">Test WebSocket</button>
            </div>

            <div id="websocket-status" class="websocket-status status-disconnected">WebSocket: Not Connected</div>
            
            <div id="ConfirmationMessage" style="margin-top: 20px; font-weight: bold; color: green;"></div>
            
            <div id="DebugOutput" style="display: block;"></div>
            
            <table class="redTable">
                <tbody id="tabla-container"></tbody>
            </table>
        </div>
    
        <script>
            const CLIENT_ID = 'c7d2a0f9-cfa1-4001-aeba-a5550f690ab1'; // Client ID to change in each Org
            const ENVIRONMENT = 'euw2.pure.cloud';
            const REDIRECT_URI = 'https://clivejdixon.github.io/index3-0.html';
            const QUEUE_ID = '8e75c14e-3d97-44df-9e81-10421015f9cb'; // Queue ID for Wholesale_Global_EN_ResetTSN_Q to change in each Org
            const SPEAK_TO_INITIAL = 'BOTH';
            const SPEAK_TO_FINAL = 'CONFERENCE';
            const SHOWDEBUG = true; // Set to false to hide debug information
            const WAITTIME = 1000;

            // WebSocket variables
            let websocket = null;
            let notificationChannelId = null;
            let isMonitoringParticipants = false;
            let debugBuffer = []; // Keep a persistent debug buffer
            let maxDebugLines = 100; // Limit buffer size

            // Enhanced debug functions
            function clearDebugOutput() {
                const debugOutput = document.getElementById("DebugOutput");
                debugOutput.textContent = '';
                debugBuffer = [];
                addDebugLine('🧹 Debug output cleared');
            }

            function toggleDebugOutput() {
                const debugOutput = document.getElementById("DebugOutput");
                debugOutput.style.display = debugOutput.style.display === 'none' ? 'block' : 'none';
            }

            function addDebugLine(message) {
                if (SHOWDEBUG) {
                    const timestamp = new Date().toLocaleTimeString();
                    const line = `[${timestamp}] ${message}`;
                    
                    // Add to buffer
                    debugBuffer.push(line);
                    if (debugBuffer.length > maxDebugLines) {
                        debugBuffer.shift();
                    }
                    
                    // Update display
                    const debugOutput = document.getElementById("DebugOutput");
                    debugOutput.textContent = debugBuffer.join('\n') + '\n';
                    debugOutput.scrollTop = debugOutput.scrollHeight;
                    
                    // Also log to console for backup
                    console.log(`[DEBUG] ${message}`);
                }
            }

            function updateWebSocketStatus(status, className) {
                const statusElement = document.getElementById("websocket-status");
                statusElement.textContent = `WebSocket: ${status}`;
                statusElement.className = `websocket-status ${className}`;
            }

            function testWebSocketConnection() {
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    addDebugLine('🧪 WebSocket test: Connection is OPEN and ready');
                    addDebugLine(`🧪 Current monitoring status: ${isMonitoringParticipants ? 'ACTIVE' : 'INACTIVE'}`);
                    addDebugLine(`🧪 Notification channel ID: ${notificationChannelId || 'None'}`);
                } else if (websocket) {
                    addDebugLine(`🧪 WebSocket test: Connection state is ${websocket.readyState} (0=CONNECTING, 1=OPEN, 2=CLOSING, 3=CLOSED)`);
                } else {
                    addDebugLine('🧪 WebSocket test: No connection established');
                }
            }

            function getTokenAndStateFromHash() {
                const hash = window.location.hash.substring(1);
                const params = new URLSearchParams(hash);
                const token = params.get('access_token');
                const state = params.get('state');
                console.log("Received state:", state);
                let conversationId = null;
                let agentParticipantId = null;
                let customerParticipantId = null;
                let consultingUserId = null;

                if (state) {
                    try {
                        const decodedState = decodeURIComponent(state);
                        const parsed = JSON.parse(atob(decodedState));
                        conversationId = parsed.conversationId;
                        agentParticipantId = parsed.agentParticipantId;
                        customerParticipantId = parsed.customerParticipantId;
                        consultingUserId = parsed.consultingUserId;
                        console.log("Parsed from state:", parsed);
                    } catch (e) {
                        console.error("Error decoding state:", e);
                    }
                }

                return { token, conversationId, agentParticipantId, customerParticipantId, consultingUserId };
            }

            function getParametersFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                return {
                    conversationId: urlParams.get('conversationId'),
                    agentParticipantId: urlParams.get('agentParticipantId'),
                    customerParticipantId: urlParams.get('customerParticipantId'),
                    consultingUserId: urlParams.get('consultingUserId')
                };
            }

            // First try to get parameters from OAuth callback (hash)
            let { token: gToken, conversationId, agentParticipantId, customerParticipantId, consultingUserId } = getTokenAndStateFromHash();

            // If no token, we need to start OAuth flow
            if (!gToken) {
                // Get parameters from URL
                const urlParams = getParametersFromUrl();
                
                if (!urlParams.conversationId || !urlParams.agentParticipantId || !urlParams.customerParticipantId || !urlParams.consultingUserId) {
                    alert("Missing parameters in the URL. Cannot continue.");
                    throw new Error("Missing parameters in the URL");
                }

                // Store parameters in state for OAuth flow
                const state = btoa(JSON.stringify({
                    conversationId: urlParams.conversationId,
                    agentParticipantId: urlParams.agentParticipantId,
                    customerParticipantId: urlParams.customerParticipantId,
                    consultingUserId: urlParams.consultingUserId                
                }));
                console.log("Redirecting with state:", state);

                const authUrl = `https://login.${ENVIRONMENT}/oauth/authorize?` + 
                    $.param({
                        response_type: 'token',
                        client_id: CLIENT_ID,
                        redirect_uri: REDIRECT_URI,
                        state: state
                    });
                window.location.replace(authUrl);
            } else {
                // We have a token, parameters should be in the state
                if (!conversationId || !agentParticipantId || !customerParticipantId || !consultingUserId) {
                    alert("Missing parameters in OAuth callback. Cannot continue.");
                    throw new Error("Missing parameters in OAuth callback");
                }

                console.log("Token obtained:", gToken);
                console.log("conversationId:", conversationId);
                console.log("agentParticipantId:", agentParticipantId);
                console.log("customerParticipantId:", customerParticipantId);
                console.log("consultingUserId:", consultingUserId);            

                const BASE_API_URL = `https://api.${ENVIRONMENT}/api/v2/conversations/calls/${conversationId}`;

                // Initialize debug display
                addDebugLine('🚀 Application initialized');
                addDebugLine(`📋 Conversation ID: ${conversationId}`);
                addDebugLine(`👤 Agent ID: ${agentParticipantId.substring(0,8)}...`);
                addDebugLine(`📞 Customer ID: ${customerParticipantId.substring(0,8)}...`);

                function sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                async function makeApiCall(endpoint, method, data, description = '') {
                    try {
                        if (SHOWDEBUG) {
                            addDebugLine(`${description}\nCalling: ${method} ${endpoint}\nPayload: ${JSON.stringify(data, null, 2)}`);
                        }
                        
                        const response = await $.ajax({
                            url: endpoint,
                            type: method,
                            beforeSend: function(xhr) {
                                xhr.setRequestHeader('Authorization', 'Bearer ' + gToken);
                            },
                            data: JSON.stringify(data),
                            contentType: 'application/json'
                        });
                        
                        console.log(`${method} response:`, response);
                        if (SHOWDEBUG) {
                            addDebugLine(`✅ SUCCESS: Status 200\nResponse: ${JSON.stringify(response, null, 2)}\n`);
                        }
                        return response;
                    } catch (error) {
                        console.error(`${method} error:`, error);
                        const errorText = error.responseText || error.statusText || error.message || 'Unknown error';
                        const statusCode = error.status || 'Unknown';
                        if (SHOWDEBUG) {
                            addDebugLine(`❌ ERROR: Status ${statusCode}\nError: ${errorText}\n`);
                        }
                        throw error;
                    }
                }

                // Enhanced WebSocket notification functions
                async function setupWebSocketNotifications() {
                    try {
                        addDebugLine('🔌 Setting up WebSocket notifications...');
                        
                        // Step 1: Create notification channel
                        const channelResponse = await makeApiCall(
                            `https://api.${ENVIRONMENT}/api/v2/notifications/channels`,
                            'POST',
                            {},
                            'Creating notification channel'
                        );
                        
                        notificationChannelId = channelResponse.id;
                        const websocketUri = channelResponse.connectUri;
                        addDebugLine(`📡 Channel created: ${notificationChannelId}`);
                        addDebugLine(`🔗 WebSocket URI: ${websocketUri}`);
                        
                        // Step 2: Subscribe to conversation events - FIXED SUBSCRIPTION
                        const subscriptionResponse = await makeApiCall(
                            `https://api.${ENVIRONMENT}/api/v2/notifications/channels/${notificationChannelId}/subscriptions`,
                            'POST',
                            [{
                                id: `v2.detail.events.conversation.${conversationId}.participant.end`
                            }],
                            'Subscribing to participant disconnect notifications'
                        );
                        
                        addDebugLine(`📬 Subscription created for: v2.detail.events.conversation.${conversationId}.participant.end`);
                        
                        // Step 3: Connect WebSocket
                        websocket = new WebSocket(websocketUri);
                        
                        websocket.onopen = function() {
                            addDebugLine('✅ WebSocket connected successfully');
                            updateWebSocketStatus('Connected', 'status-connected');
                        };
                        
                        websocket.onmessage = function(event) {
                            try {
                                const notification = JSON.parse(event.data);
                                addDebugLine(`📨 WebSocket message received: ${JSON.stringify(notification, null, 2)}`);
                                handleParticipantNotification(notification);
                            } catch (error) {
                                addDebugLine(`❌ Error parsing WebSocket message: ${error.message}`);
                            }
                        };
                        
                        websocket.onerror = function(error) {
                            console.error('WebSocket error:', error);
                            addDebugLine(`❌ WebSocket error: ${JSON.stringify(error)}`);
                            updateWebSocketStatus('Error', 'status-disconnected');
                        };
                        
                        websocket.onclose = function(event) {
                            addDebugLine(`🔌 WebSocket connection closed - Code: ${event.code}, Reason: ${event.reason}`);
                            updateWebSocketStatus('Disconnected', 'status-disconnected');
                        };
                        
                        // Wait a bit for connection to establish
                        await sleep(2000);
                        
                        if (websocket.readyState === WebSocket.OPEN) {
                            addDebugLine('🎯 WebSocket setup completed successfully');
                            return true;
                        } else {
                            addDebugLine(`⚠️ WebSocket not fully connected (state: ${websocket.readyState})`);
                            return false;
                        }
                        
                    } catch (error) {
                        console.error('Failed to setup WebSocket notifications:', error);
                        addDebugLine(`❌ WebSocket setup failed: ${error.message || error.responseText || 'Unknown error'}`);
                        updateWebSocketStatus('Setup Failed', 'status-disconnected');
                        return false;
                    }
                }

                function handleParticipantNotification(notification) {
                    addDebugLine(`🔍 Processing notification - Monitoring: ${isMonitoringParticipants}`);
                    
                    if (!isMonitoringParticipants) {
                        addDebugLine('⏸️ Not monitoring participants - ignoring notification');
                        return;
                    }
                    
                    addDebugLine(`📋 Notification details:`);
                    addDebugLine(`   Topic: ${notification.topicName}`);
                    addDebugLine(`   Event Body: ${JSON.stringify(notification.eventBody, null, 2)}`);
                    
                    // Check if this is a participant end event
                    if (notification.topicName && 
                        notification.topicName.includes('participant.end') && 
                        notification.eventBody) {
                        
                        const eventBody = notification.eventBody;
                        
                        addDebugLine(`🎯 Participant disconnect event detected:`);
                        addDebugLine(`   Disconnect Type: ${eventBody.disconnectType}`);
                        addDebugLine(`   Participant ID: ${eventBody.participantId}`);
                        addDebugLine(`   Purpose: ${eventBody.purpose}`);
                        addDebugLine(`   Duration: ${eventBody.interactingDurationMs}ms`);
                        
                        // Check if this is the customer disconnecting
                        if (eventBody.participantId === customerParticipantId) {
                            addDebugLine(`✅ Customer participant disconnect confirmed`);
                            
                            if (eventBody.disconnectType === 'ENDPOINT') {
                                addDebugLine('🎯 Customer ENDPOINT disconnect detected - taking agent off hold...');
                                
                                // Stop monitoring to prevent multiple triggers
                                isMonitoringParticipants = false;
                                updateWebSocketStatus('Monitoring Stopped', 'status-disconnected');
                                
                                // Take agent off hold
                                takeAgentOffHold();
                            } else {
                                addDebugLine(`ℹ️ Customer disconnected but not ENDPOINT type: ${eventBody.disconnectType}`);
                            }
                        } else {
                            addDebugLine(`ℹ️ Different participant disconnected: ${eventBody.participantId}`);
                        }
                    } else {
                        addDebugLine('ℹ️ Notification not a participant end event');
                    }
                }

                async function takeAgentOffHold() {
                    try {
                        await makeApiCall(
                            `${BASE_API_URL}/participants/${agentParticipantId}`,
                            'PATCH',
                            {
                                held: false
                            },
                            'FINAL STEP: Taking agent off hold'
                        );
                        
                        addDebugLine('🎉 Agent taken off hold - TSN Reset sequence complete!');
                        document.getElementById("ConfirmationMessage").textContent = "✅ TSN Reset completed - Agent off hold";
                        
                        // Clean up WebSocket after successful completion
                        cleanupWebSocket();
                        
                    } catch (error) {
                        console.error("Error taking agent off hold:", error);
                        addDebugLine(`❌ Error taking agent off hold: ${error.responseText || error.message}`);
                        document.getElementById("ConfirmationMessage").textContent = "❌ Error taking agent off hold";
                    }
                }

                function cleanupWebSocket() {
                    if (websocket) {
                        websocket.close();
                        websocket = null;
                        addDebugLine('🧹 WebSocket cleaned up');
                        updateWebSocketStatus('Cleaned Up', 'status-disconnected');
                    }
                    isMonitoringParticipants = false;
                }

                // Clean up on page unload
                window.addEventListener('beforeunload', function() {
                    cleanupWebSocket();
                });

                // Keep WebSocket alive with heartbeat
                function startWebSocketHeartbeat() {
                    setInterval(() => {
                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            // Send a ping message to keep connection alive
                            try {
                                websocket.send(JSON.stringify({type: 'ping'}));
                            } catch (error) {
                                addDebugLine(`⚠️ Heartbeat failed: ${error.message}`);
                            }
                        }
                    }, 30000); // Every 30 seconds
                }

                window.startSequence = async function() {
                    document.getElementById("ConfirmationMessage").textContent = "Processing...";
                    addDebugLine('🚀 Starting TSN Reset sequence...');

                    try {
                        // Try to setup WebSocket notifications (non-blocking)
                        const websocketSetupSuccess = await setupWebSocketNotifications();
                        
                        if (websocketSetupSuccess) {
                            startWebSocketHeartbeat();
                        }
                        
                        // Step 1: Try POST consult first, fallback to POST participants
                        let step1Success = false;
                        try {
                            // Step 1a: POST consult
                            await makeApiCall(
                                `${BASE_API_URL}/participants/${customerParticipantId}/consult`,
                                'POST',
                                {
                                    speakTo: SPEAK_TO_INITIAL,
                                    destination: {
                                        queueId: QUEUE_ID
                                    },
                                    consultingUserId: consultingUserId
                                },
                                'STEP 1a: Creating consultation'
                            );
                            step1Success = true;
                        } catch (error) {
                            addDebugLine(`⚠️ Step 1a failed (likely already in conference), trying fallback approach...`);
                            
                            try {
                                // Step 1b: POST participants (fallback)
                                await makeApiCall(
                                    `${BASE_API_URL}/participants`,
                                    'POST',
                                    {
                                        "participants": [{"queueId": QUEUE_ID}]
                                    },
                                    'STEP 1b: Adding queue to conference (fallback)'
                                );
                                step1Success = true;
                                addDebugLine('✅ Step 1b fallback succeeded - skipping to Step 3 (conference already active)');
                                
                                // Skip Steps 2 and go directly to Step 3 since we're already in conference mode
                                addDebugLine('⏳ Waiting 1 second before final step...');
                                await sleep(WAITTIME);
                                
                                // Step 3: PATCH participant held
                                await makeApiCall(
                                    `${BASE_API_URL}/participants/${agentParticipantId}`,
                                    'PATCH',
                                    {
                                        held: true
                                    },
                                    'STEP 3: Placing agent on hold'
                                );

                                // Start monitoring for participant changes (only if WebSocket is working)
                                if (websocketSetupSuccess) {
                                    isMonitoringParticipants = true;
                                    updateWebSocketStatus('Monitoring Active', 'status-monitoring');
                                    addDebugLine('👁️ Now monitoring for customer disconnections...');
                                    document.getElementById("ConfirmationMessage").textContent = "✅ Agent on hold - Monitoring for disconnections";
                                } else {
                                    addDebugLine('⚠️ WebSocket monitoring unavailable - sequence completed');
                                    document.getElementById("ConfirmationMessage").textContent = "✅ Agent on hold - Manual monitoring required";
                                }
                                
                                return; // Exit early since we've completed the sequence
                            } catch (fallbackError) {
                                addDebugLine(`❌ Both Step 1a and 1b failed`);
                                throw fallbackError; // Re-throw to trigger main error handling
                            }
                        }

                        // Wait time pause
                        addDebugLine('⏳ Waiting 1 second...');
                        await sleep(WAITTIME);

                        // Step 2: Try PATCH consult first, fallback to POST participants
                        let step2Success = false;
                        try {
                            // Step 2a: PATCH consult
                            await makeApiCall(
                                `${BASE_API_URL}/participants/${customerParticipantId}/consult`,
                                'PATCH',
                                {
                                    speakTo: SPEAK_TO_FINAL,
                                    consultingUserId: consultingUserId
                                },
                                'STEP 2a: Updating consultation speak mode'
                            );
                            step2Success = true;
                        } catch (error) {
                            addDebugLine(`⚠️ Step 2a failed, trying fallback approach...`);
                            
                            try {
                                // Step 2b: POST participants (fallback)
                                await makeApiCall(
                                    `${BASE_API_URL}/participants`,
                                    'POST',
                                    {
                                        "participants": [{"queueId": QUEUE_ID}]
                                    },
                                    'STEP 2b: Adding queue to conference (fallback)'
                                );
                                step2Success = true;
                                addDebugLine('✅ Step 2b fallback succeeded');
                            } catch (fallbackError) {
                                addDebugLine(`❌ Both Step 2a and 2b failed`);
                                throw fallbackError; // Re-throw to trigger main error handling
                            }
                        }

                        // Wait time pause
                        addDebugLine('⏳ Waiting 1 second...');
                        await sleep(WAITTIME);

                        // Step 3: PATCH participant held
                        await makeApiCall(
                            `${BASE_API_URL}/participants/${agentParticipantId}`,
                            'PATCH',
                            {
                                held: true
                            },
                            'STEP 3: Placing agent on hold'
                        );

                        // Start monitoring for participant changes (only if WebSocket is working)
                        if (websocketSetupSuccess) {
                            isMonitoringParticipants = true;
                            updateWebSocketStatus('Monitoring Active', 'status-monitoring');
                            addDebugLine('👁️ Now monitoring for customer disconnections...');
                            addDebugLine('🎉 Initial sequence completed successfully!');
                            document.getElementById("ConfirmationMessage").textContent = "✅ Agent on hold - Monitoring for disconnections";
                        } else {
                            addDebugLine('⚠️ WebSocket monitoring unavailable - sequence completed');
                            addDebugLine('🎉 Initial sequence completed successfully!');
                            document.getElementById("ConfirmationMessage").textContent = "✅ Agent on hold - Manual monitoring required";
                        }
                        
                    } catch (error) {
                        console.error("Sequence error:", error);
                        addDebugLine(`💥 SEQUENCE FAILED: ${error.responseText || error.message}`);
                        document.getElementById("ConfirmationMessage").textContent = "❌ Error during sequence execution: " + (error.responseText || error.message);
                        
                        // Clean up on error
                        cleanupWebSocket();
                    }
                };
            }
        </script>
    </body>
</html>
